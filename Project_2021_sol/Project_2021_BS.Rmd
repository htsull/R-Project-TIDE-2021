---
title: "Project 2021 TIDE"
author: "Berthony Sully & Landy Clément"
date: "9/16/2021"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

### 1.Proposer un code permettant de regrouper les données contenues dans movies.zip dans un seul et même data.frame.
```{r, message = FALSE} 
#Attach the necessary libraries
library(dplyr)
library(readr)

#1. Capture the raw pat of the zip folder
raw_path <- "./movies.zip"

#2. unzip the folder
data <- unzip(raw_path, files = NULL, list = F, exdir = "movie_unzip")

#3. Capture the new path to the folder that contains the datasets
path_ <- "./movie_unzip"

#4. Create a function to merge all the datasets
merge_df = function(path_to_folder){

  #capture the names of the files in the folder
  list_name_file = list.files(path = path_to_folder, full.names = T)
  
  #read all the files in the folder
  data_list = lapply(list_name_file, function(x){
    read.csv(file = x, header = TRUE)
    }) #x --> names of the files to read (in this case 'list_name_file')
  
  #combine the datasets with the reduce function 
  #after merging them two by two (merge function)
  Reduce(function(x, y){merge(x, y, all = T)}, data_list)
}

#5. Store the complete merged dataset
# df <- merge_df(path_)

# write.csv(x = df, file = "complete_data.csv")

complete_data <- read.csv(file = "./complete_data.csv", header = T)

```

### 2. Observer pour chaque variable, le nombre et la proportion de valeurs manquantes.

```{r}
#  Presentage of missng values
na_percent <- round(na_num/sum(is.na(complete_data) * 100), 3)

print.table(na_percent)
```
#### Nous constatons que la variable Country ne contient pas de NA. Cependant, ladite variavle et d'autres ont des cases vides. Ainsi, nous avons  décidé de les gérer comme des NAs.

```{r}
complete_data[complete_data == ""]<- NA # Remplacer les vides par des NAs.
```

### 2.1. Observons à nouveau pour chaque variable, le nombre et la proportion de valeurs manquantes.

```{r}
#  Presentage of missng values
round(sapply(complete_data,function(x) sum(is.na(x))/length(x))*100, 2)
```

### 3. Représenter graphiquement la distribution de la durée des films

```{r}
library(tidyverse)
complete_data$duration <- as.numeric(complete_data$duration)
ggplot(complete_data, aes(x = duration)) +
  geom_histogram(color = "red", fill = 'green', binwidth = 50, alpha = 1)  + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  labs(title = 'Représentation graphique de la durée des films', x = 'Durée', y = 'Effectif') +
  scale_y_continuous(n.breaks = 15) +
  scale_x_continuous(n.breaks = 20)
```
### 4. Compter le nombre de films dans lesquels la langue française apparait.

```{r}
library(stringr)
complete_data %>% 
  filter(str_detect(language, "French|.French.")) %>% 
  select(language) %>% 
  count() %>% 
  paste(.,'films sont disponibles en francais')
```


### 5. Créer une variable permettant de discrétiser la variable year par décennie (ex : 1975 => Entre 1970 et 1980, 1995 => Entre 1990 et 2000, 2001 => Entre 2000 et 2010…)

```{r}
paste("La variable Year est de type :", typeof(complete_data$year))
```
#### On peut essayer de voir les valeurs uniques de year pour avoir une plus nette explication
```{r}
unique(complete_data$year)
```
#### La valeur "TV Movie 2019" semble être le probleme. Pour cela, étant donné qu'on connait le contexe on peut remplacer cette valeur par "2019" et convertir la variable au type 'numeric.


```{r, message=FALSE, warning=FALSE}
# Select year column
complete_data$year <- complete_data$year %>% 
  #convert as numeric type
  as.numeric %>% 
  #replace the NA value with 2019
  replace_na(., 2019)
#show unique value of recently created year column
unique(complete_data$year)
```


```{r}
#creation of the "decade variable"
complete_data$decade <- cut(complete_data$year, 
                            breaks = c(seq(1890, 
                                           2020, 10)),
                            labels = c("1890 - 1900",
                                       "1900 - 1910",
                                       "1910 - 1920",
                                       "1920 - 1930",
                                       "1930 - 1940",
                                       "1940 - 1950",
                                       "1950 - 1960",
                                       "1960 - 1970",
                                       "1970 - 1980",
                                       "1980 - 1990",
                                       "1990 - 2000",
                                       "2000 - 2010",
                                       "2010 - 2020"),
                            right = F,
                            include.lowest = T)

#randomly select some line in year and decade columns to verify the results
complete_data %>% 
  select(year, decade)%>% 
  sample_n(50)
```


### 6. Proposer une représentation graphique permettant d’observer pour chaque décennie, le nombre et la proportion de films dans lesquels la langue française apparait.

```{r}
dt <- complete_data %>%
  select(language, decade) %>% 
  group_by(decade) %>% 
  count(french = str_detect(language, "French|.French.")) %>% 
  mutate(p = scales::percent(n / sum(n))) %>% 
  filter(french == T)
  
ggplot(dt, aes(x=decade,y=n, fill=decade)) +
  geom_bar(stat="identity", color="black")+
  geom_text(aes(label=p), vjust=-0.3, size=3.5)+
  theme(axis.text.x = element_text(angle=90, vjust=.5, hjust=1)) + 
  labs(title = "Représentation de la quantité de films dans lesquels la langue française apparait par décenie",
       x = "Décennie", y = "Effectif")

```


### 7. Pour toutes les variables de la forme « avg_vote ». Calculer la moyenne, la médiane, l’écart type, la mad (median absolute deviation), le coefficient de variation, la valeur maximum et la valeur minimum. Représentez graphiquement ces résultats.

```{r}
data <-complete_data %>% 
  select(starts_with("avg_vote_"))

report <- function(x, name) { 
  tibble(
    variable  = name, 
    mean = round(mean(x, na.rm = FALSE), 2),
    median = round(median(x, na.rm = FALSE), 2),
    sd = round(sd(x), 2),
    
    mad = round(mad(x, center = median(x), 
                    constant = 1.4826, na.rm = FALSE,
                    low = FALSE, high = FALSE), 2),
    
    coef_de_var = round((sd(x)/mean(x))*100, 2),
    max = round(max(x), 2),
    min = round(min(x), 2)
  )
}

Ind_Stat <- data %>% imap_dfr(report)
Ind_Stat
```
#### Vu que les variables avg_vote et avg_vote_10 sont identiques, on a décidé de garder que la variable avg_vote_10.

#### Représentez graphiquement ces résultats

```{r}
ggplot(Ind_Stat, aes(x=variable, y=mean, fill=variable)) +
  geom_bar(stat="identity", color="black")+
  geom_text(aes(label=mean), vjust=-0.3, size=3.5)+
  theme_minimal()

ggplot(Ind_Stat, aes(x=variable, y=median, fill=variable)) +
  geom_bar(stat="identity", color="black")+
  geom_text(aes(label=median), vjust=-0.3, size=3.5)+
  theme_minimal()

ggplot(Ind_Stat, aes(x=variable, y=sd, fill=variable)) +
  geom_bar(stat="identity", color="black")+
  geom_text(aes(label=sd), vjust=-0.3, size=3.5)+
  theme_minimal()

ggplot(Ind_Stat, aes(x=variable, y=mad, fill=variable)) +
  geom_bar(stat="identity", color="black")+
  geom_text(aes(label=mad), vjust=-0.3, size=3.5)+
  theme_minimal()

ggplot(Ind_Stat, aes(x=variable, y=coef_de_var, fill=variable)) +
  geom_bar(stat="identity", color="black")+
  geom_text(aes(label=coef_de_var), vjust=-0.3, size=3.5)+
  theme_minimal()

ggplot(Ind_Stat, aes(x=variable, y=max, fill=variable)) +
  geom_bar(stat="identity", color="black")+
  geom_text(aes(label=max), vjust=-0.3, size=3.5)+
  theme_minimal()

ggplot(Ind_Stat, aes(x=variable, y=min, fill=variable)) +
  geom_bar(stat="identity", color="black")+
  geom_text(aes(label=min), vjust=-0.3, size=3.5)+
  theme_minimal()

# library(cowplot)
# plot_grid(moy, med, sd, mad, cv, max, min, labels = c("Moy", "Med",
#                                                       "Sd", "Mad", "cv", "max", "min"), label_size = 14, hjust = -0.5, vjust =1.5, greedy = TRUE, byrow = T)
```


 
 
#### 8. Proposer une représentation graphique permettant d’observer s’il existe une différence de notation en fonction du genre de film

#### Tout d’abord il est intéressant de les représenter graphiquements au moyen de boîtes à moustaches côte à côte, pour mieux comparer les dispersions des chaques modalités de la variable qualitative(genre).


```{r}
ggplot(complete_data, mapping = aes(x=genre, y=votes))+
  geom_boxplot()
```


```{r}
ggplot(complete_data) +
  aes(x=genre, y=votes,  colour="green") +
  geom_boxplot() + 
    guides(scale="none") + coord_flip()
  xlab("Votes") +
  ylab("Genre") +
  ggtitle("Répartition de notation en fonction du genre de film")
# facet_wrap(~genre)
```


### Pour décrire le lien entre une variable catégorielle et une variable quantitative, on peut calculer certaines caractéristiques de la variable quantitative (par exemple sa moyenne) par groupe (défini par les modalités de la variable catégorielle). Pour cela, la fonction summarise() du package dplyr est tout indiquée:

```{r}
complete_data %>% 
  group_by(genre) %>% 
  summarise(moy_votes=mean(votes),
            max_votes=max(votes),
            min_votes=min(votes),
            sd_votes=sd(votes))
```

#### 9) Pour chaque genre de film, représenter graphiquement le top 10 des films les mieux notés

```{r}
View(table(complete_data$genre))
```

```{r}
top_10_film <- complete_data %>% 
  select(votes, genre) %>%
  arrange(desc(votes)) %>% 
  head(10)

complete_data %>% select(genre) %>% unique()

uniGenre <- function(vect_){
    genre1 <- vect_
    genre2 <- paste0(genre1, collapse = ',')
    genre3 <- strsplit(genre2, ",")
    genre4 <- genre3[[1]] %>% unique %>% sort
    return(genre4)
}

fon <- uniGenre(complete_data$genre)

complete_data$original_title[grepl('Action', complete_data$genre)] %>% length()

for i in fon{
  complete_data$genre[grepl(i, complete_data$genre)] %>% length()
}





complete_data$
top_10_film %>%
  select(votes, genre)
  
  ggplot(top_10_film, aes(x=genre,y=votes, fill=genre)) +
  geom_bar(stat="identity", color="black")+
  theme_minimal() + 
  labs(title = "représenter graphiquement le top 10 des films les mieux notés",
       x = "Genre", y = "Nbre_de_votes")
```



```{r}
typeof(complete_data$votes)
```









